{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/util/rand.ts","../src/method/splitThenMerge.ts","../src/util/splitChunk.ts","../src/util/filterLands.ts","../src/util/groupByName.ts","../src/util/distributeGroup.ts","../src/method/distributeCards.ts","../src/method/ensureLands.ts","../src/util/findIndexOfLands.ts","../src/library.ts"],"sourcesContent":["import { IOptionsDeckLibraryWithShuffle } from '../types';\nimport { IRNGLike } from '@lazy-random/rng-abstract';\nimport { simpleWrap } from '@lazy-random/simple-wrap';\nimport { _MathRandom } from '@lazy-random/original-math-random';\nimport { dfArrayShuffle } from '@lazy-random/df-array';\n\nlet _cacheRNG: IRNGLike;\n\nexport function defaultRNG()\n{\n\treturn _cacheRNG ??= simpleWrap(_MathRandom)\n}\n\nexport function getRandomFromOptions(options?: IOptionsDeckLibraryWithShuffle): IRNGLike\n{\n\tconst random = (options?.random ?? defaultRNG());\n\n\treturn random as any\n}\n\nexport function rngArrayShuffle<T>(random: IRNGLike, arr: T[], overwrite?: boolean)\n{\n\treturn dfArrayShuffle(random, arr, overwrite)();\n}\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { splitChunk } from '../util/splitChunk';\nimport { getRandomFromOptions, rngArrayShuffle } from '../util/rand';\nimport { IOptionsDeckLibraryWithShuffle } from '../types';\nimport { DeckLibraryWithShuffle } from '../library';\n\n/**\n * split cards chunk and merge by random oder\n */\nexport function splitThenMerge<T = ICardWithoutAmount>(cards: T[],\n\toptions?: IOptionsDeckLibraryWithShuffle,\n\tself?: DeckLibraryWithShuffle,\n): T[]\n{\n\tlet arr = splitChunk(cards, options?.maxChunkLength)\n\n\treturn rngArrayShuffle(getRandomFromOptions(options), arr, true).flat()\n}\n\nexport default splitThenMerge\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { arrayChunkSplit } from 'array-chunk-split';\n\nexport function splitChunk<T = ICardWithoutAmount>(cards: T[], maxChunkLength?: number)\n{\n\treturn arrayChunkSplit(cards, maxChunkLength ?? 12)\n}\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { parseSnowCoveredOrBaseLand } from 'mtg-base-land';\n\nexport function filterLands<T extends ICardWithoutAmount = ICardWithoutAmount>(cards: T[])\n{\n\treturn cards.reduce((data, card) =>\n\t{\n\n\t\tlet info = parseSnowCoveredOrBaseLand(card.name);\n\n\t\tif (!info)\n\t\t{\n\t\t\tdata.others.push(card);\n\t\t}\n\t\telse if (info?.snow)\n\t\t{\n\t\t\tdata.snowLands.push(card);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata.baseLands.push(card);\n\t\t}\n\n\t\treturn data\n\t}, {\n\t\tbaseLands: [] as T[],\n\t\tsnowLands: [] as T[],\n\t\tothers: [] as T[],\n\t})\n}\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { arrayGroupToRecord } from 'array-group-to-record';\n\nexport function groupByName<T extends ICardWithoutAmount = ICardWithoutAmount>(cards: T[])\n{\n\treturn arrayGroupToRecord(cards, {\n\t\tgetKey(item: T, index: number, arr: T[]): string {\n\t\t\treturn item.name\n\t\t},\n\t})\n}\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { distributeGroupToArray } from 'distribute-group-to-array';\n\nexport function distributeGroup<T extends ICardWithoutAmount = ICardWithoutAmount>(group: Record<string, T[]>)\n{\n\treturn distributeGroupToArray(group, {\n\t\tgroupArraySize: 4,\n\t})\n}\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { IOptionsDeckLibraryWithShuffle } from '../types';\nimport { filterLands } from '../util/filterLands';\nimport { groupByName } from '../util/groupByName';\nimport { distributeGroup } from '../util/distributeGroup';\nimport { createGroupArray } from '../util/createGroupArray';\nimport { DeckLibraryWithShuffle } from '../library';\n\n/**\n * do distribute before shuffle\n *\n * - distribute lands\n * - distribute cards and insert lands every 4 cards\n */\nexport function distributeCards<T extends ICardWithoutAmount = ICardWithoutAmount>(cards: T[],\n\toptions?: IOptionsDeckLibraryWithShuffle,\n\tself?: DeckLibraryWithShuffle,\n): T[]\n{\n\tlet data = filterLands(cards);\n\n\tlet arr = createGroupArray<T>(4);\n\n\tlet idx = 0;\n\n\tdata.baseLands = distributeGroup(groupByName(data.baseLands));\n\tdata.snowLands = distributeGroup(groupByName(data.snowLands));\n\n\twhile (data.baseLands.length || data.snowLands.length || data.others.length)\n\t{\n\n\t\tfor (let i = 0; i < 4; i++)\n\t\t{\n\t\t\tlet card = data.others.pop();\n\t\t\tarr[i].push(card);\n\n\t\t\tif (!card || (idx % 4) === 0)\n\t\t\t{\n\t\t\t\tarr[i].push(data.baseLands.pop() ?? data.snowLands.pop());\n\t\t\t\tarr[i].push(data.baseLands.pop() ?? data.snowLands.pop());\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\n\t}\n\n\treturn arr.flat().filter(c => c)\n}\n\nexport default distributeCards\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { IOptionsDeckLibraryWithShuffle } from '../types';\nimport { DeckLibraryWithShuffle } from '../library';\nimport { filterLands } from '../util/filterLands';\nimport { findIndexOfLands } from '../util/findIndexOfLands';\nimport { getRandomFromOptions } from '../util/rand';\nimport { dfArrayUnique } from '@lazy-random/df-array';\n\n/**\n * ensure always has lands when handSize >= 6\n */\nexport function ensureLands<T extends ICardWithoutAmount = ICardWithoutAmount>(cards: T[],\n\toptions: IOptionsDeckLibraryWithShuffle,\n\tself: DeckLibraryWithShuffle,\n): T[]\n{\n\tcards = cards.slice();\n\n\tlet min: number;\n\n\tif (options?.ensureLands === false)\n\t{\n\t\treturn cards\n\t}\n\telse if (options?.ensureLands === true)\n\t{\n\t\tmin = 2;\n\t}\n\telse\n\t{\n\t\tmin = Math.max(Math.min(2, (options?.ensureLands | 0) || 2), 0);\n\t}\n\n\tif (self.handSize < 6 || min <= 0)\n\t{\n\t\treturn cards\n\t}\n\telse if (self.handSize === 6)\n\t{\n\t\tmin = 1;\n\t}\n\n\tconst hands = cards.slice(0, self.handSize);\n\n\tconst data = filterLands(hands);\n\n\tconst lands = data.snowLands.length + data.baseLands.length;\n\n\tconst diff = lands - min;\n\n\tif (diff > 0)\n\t{\n\n\t\tconst idxLandArray = findIndexOfLands(cards, self.handSize);\n\n\t\tconst random = getRandomFromOptions(options);\n\n\t\tconst fnLibraryLand = dfArrayUnique(random, idxLandArray, diff);\n\n\t\tlet fnHandCard = dfArrayUnique(random, data.others, diff);\n\n\t\tfor (let i = 0; i < diff; i++)\n\t\t{\n\t\t\tconst card = fnHandCard();\n\t\t\tconst idxLibraryLand = fnLibraryLand();\n\n\t\t\tconst idxHand = hands.findIndex(value =>\n\t\t\t{\n\t\t\t\treturn value.name === card.name\n\t\t\t});\n\n\t\t\tif (idxHand === -1)\n\t\t\t{\n\t\t\t\tthrow new Error(`Something wrong`)\n\t\t\t}\n\n\t\t\tconst c1 = cards[idxLibraryLand];\n\t\t\tconst c2 = cards[idxHand];\n\n\t\t\tcards[idxLibraryLand] = c2;\n\t\t\thands[idxHand] = cards[idxHand] = c1;\n\t\t}\n\n\t}\n\n\treturn cards\n}\n","import { ICardWithoutAmount } from 'mtg-decklist-parser2';\nimport { parseSnowCoveredOrBaseLand } from 'mtg-base-land';\n\nexport function findIndexOfLands<T extends ICardWithoutAmount = ICardWithoutAmount>(cards: T[], startIndex?: number)\n{\n\tstartIndex |= 0;\n\n\treturn cards.reduce((list, card, idx) =>\n\t{\n\n\t\tif (idx >= startIndex)\n\t\t{\n\t\t\tlet info = parseSnowCoveredOrBaseLand(card.name);\n\n\t\t\tif (info)\n\t\t\t{\n\t\t\t\tlist.push(idx);\n\t\t\t}\n\t\t}\n\n\t\treturn list\n\t}, [] as number[])\n}\n","import { DeckLibrary, ICardOfLibrary } from 'mtg-decklist-to-library';\nimport { IOptionsDeckLibraryWithShuffle } from './types';\nimport { getRandomFromOptions, rngArrayShuffle } from './util/rand';\nimport { splitThenMerge } from './method/splitThenMerge';\nimport { Decklist } from 'mtg-decklist-parser2';\nimport { distributeCards } from './method/distributeCards';\nimport { ensureLands } from './method/ensureLands';\nimport { int } from '@lazy-random/util-distributions';\n\nexport class DeckLibraryWithShuffle<T = {}> extends DeckLibrary<ICardOfLibrary<T>>\n{\n\n\tpublic _options?: IOptionsDeckLibraryWithShuffle<ICardOfLibrary<T>>;\n\n\tconstructor(deck: Decklist, options?: IOptionsDeckLibraryWithShuffle<ICardOfLibrary<T>>)\n\t{\n\t\tsuper(deck, options);\n\t}\n\n\toptions(options?: IOptionsDeckLibraryWithShuffle): IOptionsDeckLibraryWithShuffle\n\t{\n\t\treturn {\n\t\t\t...this._options,\n\t\t\t...options,\n\t\t}\n\t}\n\n\toverride shuffleStarting()\n\t{\n\t\tlet options = this.options();\n\n\t\tconst random = getRandomFromOptions(options);\n\n\t\toptions.ensureLands ??= int(random, 0, 2);\n\n\t\tlet cards = [\n\t\t\tdistributeCards,\n\t\t\tsplitThenMerge,\n\t\t\tensureLands,\n\t\t].reduce((cards, fn) => fn(cards, options, this), this.cards);\n\n\t\tthis.cards = cards;\n\t\tthis._shuffleStarting = true;\n\t}\n\n\toverride shuffle(isStarting?: boolean)\n\t{\n\t\tlet random = getRandomFromOptions(this.options());\n\n\t\tif (isStarting)\n\t\t{\n\n\t\t}\n\n\t\trngArrayShuffle(random, this.cards, true);\n\t}\n\n}\n"],"names":["_cacheRNG","getRandomFromOptions","options","random","simpleWrap","_MathRandom","rngArrayShuffle","arr","overwrite","dfArrayShuffle","splitThenMerge","cards","self","maxChunkLength","arrayChunkSplit","splitChunk","flat","filterLands","reduce","data","card","info","parseSnowCoveredOrBaseLand","name","snow","snowLands","push","baseLands","others","groupByName","arrayGroupToRecord","getKey","item","index","distributeGroup","group","distributeGroupToArray","groupArraySize","distributeCards","createGroupArray","idx","length","i","pop","filter","c","ensureLands","min","slice","Math","max","handSize","hands","diff","idxLandArray","startIndex","list","findIndexOfLands","fnLibraryLand","dfArrayUnique","fnHandCard","idxLibraryLand","idxHand","findIndex","value","Error","c1","DeckLibraryWithShuffle","DeckLibrary","constructor","deck","this","_options","shuffleStarting","int","fn","_shuffleStarting","shuffle","isStarting"],"mappings":"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"}